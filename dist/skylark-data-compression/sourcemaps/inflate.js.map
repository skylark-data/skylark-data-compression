{"version":3,"sources":["inflate.js"],"names":["define","zlib_inflate","utils","strings","msg","ZStream","GZheader","constants","toString","Object","prototype","Z_NO_FLUSH","Z_FINISH","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Inflate","options","this","assign","chunkSize","windowBits","to","opt","raw","err","ended","chunks","strm","avail_out","status","inflateInit2","Error","header","inflateGetHeader","dictionary","string2buf","call","Uint8Array","inflateSetDictionary","push","data","flush_mode","_flush_mode","last_avail_out","input","next_in","avail_in","length","output","next_out","inflate","state","wrap","inflateReset","onEnd","next_out_utf8","utf8border","tail","utf8str","buf2string","set","subarray","onData","inflateEnd","chunk","result","join","flattenChunks","uncompress","inflator"],"mappings":"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","file":"../inflate.js","sourcesContent":["define([\n    './zlib/inflate',\n    './utils/common',\n    './utils/strings',\n    './zlib/messages',\n    './zlib/zstream',\n    './zlib/gzheader',\n    './zlib/constants'\n], function (zlib_inflate, utils, strings, msg, ZStream, GZheader, constants) {\n    'use strict';\n\n\n    const toString = Object.prototype.toString;\n    const {Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR} = constants;\n    function Inflate(options) {\n        this.options = utils.assign({\n            chunkSize: 1024 * 64,\n            windowBits: 15,\n            to: ''\n        }, options || {});\n        const opt = this.options;\n        if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {\n            opt.windowBits = -opt.windowBits;\n            if (opt.windowBits === 0) {\n                opt.windowBits = -15;\n            }\n        }\n        if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {\n            opt.windowBits += 32;\n        }\n        if (opt.windowBits > 15 && opt.windowBits < 48) {\n            if ((opt.windowBits & 15) === 0) {\n                opt.windowBits |= 15;\n            }\n        }\n        this.err = 0;\n        this.msg = '';\n        this.ended = false;\n        this.chunks = [];\n        this.strm = new ZStream();\n        this.strm.avail_out = 0;\n        let status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);\n        if (status !== Z_OK) {\n            throw new Error(msg[status]);\n        }\n        this.header = new GZheader();\n        zlib_inflate.inflateGetHeader(this.strm, this.header);\n        if (opt.dictionary) {\n            if (typeof opt.dictionary === 'string') {\n                opt.dictionary = strings.string2buf(opt.dictionary);\n            } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n                opt.dictionary = new Uint8Array(opt.dictionary);\n            }\n            if (opt.raw) {\n                status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n                if (status !== Z_OK) {\n                    throw new Error(msg[status]);\n                }\n            }\n        }\n    }\n    Inflate.prototype.push = function (data, flush_mode) {\n        const strm = this.strm;\n        const chunkSize = this.options.chunkSize;\n        const dictionary = this.options.dictionary;\n        let status, _flush_mode, last_avail_out;\n        if (this.ended)\n            return false;\n        if (flush_mode === ~~flush_mode)\n            _flush_mode = flush_mode;\n        else\n            _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n        if (toString.call(data) === '[object ArrayBuffer]') {\n            strm.input = new Uint8Array(data);\n        } else {\n            strm.input = data;\n        }\n        strm.next_in = 0;\n        strm.avail_in = strm.input.length;\n        for (;;) {\n            if (strm.avail_out === 0) {\n                strm.output = new Uint8Array(chunkSize);\n                strm.next_out = 0;\n                strm.avail_out = chunkSize;\n            }\n            status = zlib_inflate.inflate(strm, _flush_mode);\n            if (status === Z_NEED_DICT && dictionary) {\n                status = zlib_inflate.inflateSetDictionary(strm, dictionary);\n                if (status === Z_OK) {\n                    status = zlib_inflate.inflate(strm, _flush_mode);\n                } else if (status === Z_DATA_ERROR) {\n                    status = Z_NEED_DICT;\n                }\n            }\n            while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {\n                zlib_inflate.inflateReset(strm);\n                status = zlib_inflate.inflate(strm, _flush_mode);\n            }\n            switch (status) {\n            case Z_STREAM_ERROR:\n            case Z_DATA_ERROR:\n            case Z_NEED_DICT:\n            case Z_MEM_ERROR:\n                this.onEnd(status);\n                this.ended = true;\n                return false;\n            }\n            last_avail_out = strm.avail_out;\n            if (strm.next_out) {\n                if (strm.avail_out === 0 || status === Z_STREAM_END) {\n                    if (this.options.to === 'string') {\n                        let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n                        let tail = strm.next_out - next_out_utf8;\n                        let utf8str = strings.buf2string(strm.output, next_out_utf8);\n                        strm.next_out = tail;\n                        strm.avail_out = chunkSize - tail;\n                        if (tail)\n                            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n                        this.onData(utf8str);\n                    } else {\n                        this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n                    }\n                }\n            }\n            if (status === Z_OK && last_avail_out === 0)\n                continue;\n            if (status === Z_STREAM_END) {\n                status = zlib_inflate.inflateEnd(this.strm);\n                this.onEnd(status);\n                this.ended = true;\n                return true;\n            }\n            if (strm.avail_in === 0)\n                break;\n        }\n        return true;\n    };\n    Inflate.prototype.onData = function (chunk) {\n        this.chunks.push(chunk);\n    };\n    Inflate.prototype.onEnd = function (status) {\n        if (status === Z_OK) {\n            if (this.options.to === 'string') {\n                this.result = this.chunks.join('');\n            } else {\n                this.result = utils.flattenChunks(this.chunks);\n            }\n        }\n        this.chunks = [];\n        this.err = status;\n        this.msg = this.strm.msg;\n    };\n    \n    Inflate.uncompress = function(input, options) {\n        const inflator = new Inflate(options);\n        inflator.push(input);\n        if (inflator.err)\n            throw inflator.msg || msg[inflator.err];\n        return inflator.result;\n    }\n    function inflateRaw(input, options) {\n        options = options || {};\n        options.raw = true;\n        return inflate(input, options);\n    }\n\n\n    return Inflate;\n  \n});"]}